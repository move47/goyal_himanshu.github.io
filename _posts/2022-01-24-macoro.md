---
layout: post
title: "Back Porting C++20 Coroutines to C++14 -- A Tutorial"
excerpt_separator: <!--more-->
categories:
  - Blog
tags:
  - cpp
  - coroutine
---


This post gives another perspective on the C++20  coroutines by presenting a [small library](http://github.com/ladnir/macoro) that emulates them using C++14 and a couple macros to aid readability. For example, the following two functions <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style=";color:#74531f;">g20</span><span style="color:#111110">()</span></span>, <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:#74531f;">g14</span><span style="color:#111110">()</span></span> both implement the same coroutine functionality. While the C++20 version is clearly a bit simpler, both are functionally equivalent and sufficiently readable. Next, we will unpack what the ''coroutine transformation'' is and how it can [partially] be implemented without specialized compiler support.

<!-- ```c++
my_future<int>  h();

// C++20 version
my_future<int> g1()
{
  int i = co_await h();
  if(i == 42)
    i = 0;
  co_return i;
}

// C++14 version
my_future<int> g2()
{
  // Specify the return type any lambda capture and local variables.
  CO_BEGIN(my_future<int>, i = int{});

  // assign the result of h() to i
  CO_AWAIT(i, h());
  if(i == 42)
    i = 0;
  CO_RETURN(i);

  CO_END();
}
``` -->


<pre style="font-family:Consolas;font-size:13px;color:black;background:#e9e9e8;border-radius:10px;padding-left:10px;padding-right:5px;"><span style="background:#e9e9e9;color:#2b91af;">my_future</span>&lt;<span style="background:#e9e9e9;color:blue;">int</span>&gt;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#74531f;">h</span>();
 
<span style="background:#e9e9e9;color:green;">//&nbsp;C++20&nbsp;version</span>
<span style="background:#e9e9e9;color:#2b91af;">my_future</span>&lt;<span style="background:#e9e9e9;color:blue;">int</span>&gt;&nbsp;<span style="background:#e9e9e9;color:#74531f;">g20</span>()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:blue;">int</span>&nbsp;<span style="background:#e9e9e9;color:#1f377f;">i</span>&nbsp;=&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">co_await</span>&nbsp;<span style="background:#e9e9e9;color:#74531f;">h</span>();
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">if</span>&nbsp;(<span style="background:#e9e9e9;color:#1f377f;">i</span>&nbsp;==&nbsp;42)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#1f377f;">i</span>&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">co_return</span>&nbsp;<span style="background:#e9e9e9;color:#1f377f;">i</span>;
}
 
<span style="background:#e9e9e9;color:green;">//&nbsp;C++14&nbsp;version</span>
<span style="background:#e9e9e9;color:#2b91af;">my_future</span>&lt;<span style="background:#e9e9e9;color:blue;">int</span>&gt;&nbsp;<span style="background:#e9e9e9;color:#74531f;">g14</span>()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:green;">//&nbsp;Specify&nbsp;the&nbsp;return&nbsp;type&nbsp;and&nbsp;lambda&nbsp;capture&nbsp;and&nbsp;local&nbsp;variables.</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8a1bff;">CO_BEGIN</span>(<span style="background:#e9e9e9;color:#2b91af;">my_future</span>&lt;<span style="background:#e9e9e9;color:blue;">int</span>&gt;,&nbsp;i&nbsp;=&nbsp;<span style="background:#e9e9e9;color:blue;">int</span>{});
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:green;">//&nbsp;assign&nbsp;the&nbsp;result&nbsp;of&nbsp;h()&nbsp;to&nbsp;i</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8a1bff;">CO_AWAIT</span>(i,&nbsp;<span style="background:#e9e9e9;color:#74531f;">h</span>());
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">if</span>&nbsp;(i&nbsp;==&nbsp;42)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8a1bff;">CO_RETURN</span>(i);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8a1bff;">CO_END</span>();
}</pre>



Due to certain limitations of macros, etc., all local variables that span a  <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;font-family:Consolas;;color:#8a1bff;">CO_XXXX</span> macro must be "lambda captured" in the <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;font-family:Consolas;;color:#8a1bff;">CO_BEGIN</span> macro. We will discuss this more below but <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;font-family:Consolas;;color:#8a1bff;">CO_BEGIN</span> must be passed the return type followed by the body of a lambda capture as if the rest of the code is in a lambda that can not have local variables. For example, <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;font-family:Consolas;;"><span style="color:#8a1bff;">CO_END</span>(<span style="color:#2b91af;">my_future</span><span style="color:#111111;">&lt;</span><span style="color:blue;">int</span><span style="color:#111111;">&gt;</span>, i = <span style="color:blue;">int</span>{});</span> loosely gets translated into


<!-- ```C++
[i = int{}]() -> my_future<int> {
  <body-of-the-coroutine>
}
``` -->


<pre style="font-family:Consolas;font-size:13px;color:black;background:#e9e9e8;border-radius:10px;padding-left:10px;padding-right:5px;">[i&nbsp;=&nbsp;<span style="background:#e9e9e9;color:blue;">int</span>{}]&nbsp;()-&gt;<span style="background:#e9e9e9;color:#2b91af;">my_future</span>&lt;<span style="background:#e9e9e9;color:blue;">int</span>&gt;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:green;">//&lt;body-of-the-coroutine&gt;</span>
}</pre>
This likely gives the reader a hint at how we will port C++20 coroutines back to C++14.


## Coroutine Usage


First, let us review some basic coroutine functionality. If the reader is familiar with coroutines feel free to skip to the next section. Coroutines can be thought of as a stateful function that can "pause" its execution and then be resumed later by the caller or someone else.


###   <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;font-family:Consolas;;color:#8f08c4;">co_await</span>


There are a couple of situations where a coroutine might be paused, or "suspend" in coroutine terminology. The most common is when the coroutine executes a  <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;font-family:Consolas;;color:#8f08c4;">co_await</span> call of some [awaitable](https://en.cppreference.com/w/cpp/language/coroutines#co_await) (e.g. some other coroutine) and the result is not ready yet. For example, in the functions above we call <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;font-family:Consolas;;"><span style="color:#8f08c4;">co_await</span><span style="color:#74531f;"> h<span style="color:#111110">()</span></span></span>. The function <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;font-family:Consolas;;color:#74531f"> h<span style="color:#111110">()</span></span> returns a <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;font-family:Consolas;;"><span style="color:#2b91af;">my_future</span><span style="color:#111111;">&lt;</span><span style="color:blue;">int</span><span style="color:#111111;">&gt;</span></span> which implements the interface of an "awaitable" with value type <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;font-family:Consolas;;color:blue;">int</span>. This interface allows the compiler to auto generate some code that determines if the underlying value is ready now or if the current coroutine should suspend while we wait for <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;font-family:Consolas;;color:#74531f"> h<span style="color:#111110">()</span></span> to complete. 


To make the example a bit more concrete, <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;font-family:Consolas;;color:#74531f"> h<span style="color:#111110">()</span></span> could be fetching a value from some server on the internet which is slow. While we wait, we want to pause this coroutine and allow the caller to go do something else. Once <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;font-family:Consolas;;color:#74531f"> h<span style="color:#111110">()</span></span> finishes, our coroutine can be resumed either by <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f"> h<span style="color:#111110">()</span></span>, by some other thread or we can be notified in some way and manually resume the coroutine. The how/when/who resumes the coroutine can be customized by our return type <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:#2b91af;">my_future</span><span style="color:#111111;">&lt;</span><span style="color:blue;">int</span><span style="color:#111111;">&gt;</span></span> and what we are   <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8f08c4;">co_await</span>ing on.


If the underlying <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:blue;">int</span> that is provided by <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f"> h<span style="color:#111110">()</span></span> is ready immediately, our coroutine does not need to suspend. 
Whenever the underlying value is ready, either immediately after the call to <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f"> h<span style="color:#111110">()</span></span> or when the coroutine is resumed, execution of the coroutine continues. The next thing to be executed is compiler generated code that passes the value held in the <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:#2b91af;">my_future</span><span style="color:#111111;">&lt;</span><span style="color:blue;">int</span><span style="color:#111111;">&gt;</span></span> to the current coroutine, i.e. assigns it to <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:blue;">int</span> i</span> in our examples. More details on this compiler generated code later. Finally, execution of the coroutine continues with the next statement after the   <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8f08c4;">co_await</span>.


### <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8f08c4;">co_yield</span>


Another example of when a coroutine can be suspended is with the <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8f08c4;">co_yield</span> keyword. The exact semantics of this is customizable but typically it is used to suspend the current coroutine and pass a value back to the caller. This is similar to returning a value but we are allowed to resume the coroutine later. Typically, the caller will use this value and then resume the coroutine which can <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8f08c4;">co_yield</span> another value back to the caller or run to completion. A classic example of this is to lazily generate a range of values. For example, <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f">range20</span>, <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f">range14</span> both return a <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style=";color:#2b91af;">my_range</span><span style=";color:#111111;">&lt;</span><span style=";color:blue;">int</span><span style=";color:#111111;">&gt;</span></span> which allows the caller to iterate over the values that are <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8f08c4;">co_yield</span> out of the coroutine. This example prints the string <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;">2,3,4,5,6,7,8,9,</span>.


<!-- ```C++
my_range<int> range20(int begin, int end) {
  for(int i = begin; i < end; ++i)
    co_yield i;
}
my_range<int> range14(int begin, int end) {
  CO_BEGIN(my_range<int>, begin, end, i = int{});
  for(i = begin; i < end; ++i)
    CO_YIELD(i);
  CO_END();
}

void example() {
  for(int i : range14(2, 10))
    std::cout << i <<',';
}
``` -->


<pre style="font-family:Consolas;font-size:13px;color:black;background:#e9e9e8;border-radius:10px;padding-left:10px;padding-right:5px;"><span style="background:#e9e9e9;color:#2b91af;">my_range</span>&lt;<span style="background:#e9e9e9;color:blue;">int</span>&gt;&nbsp;<span style="background:#e9e9e9;color:#74531f;">range20</span>(<span style="background:#e9e9e9;color:blue;">int</span>&nbsp;<span style="background:#e9e9e9;color:gray;">begin</span>,&nbsp;<span style="background:#e9e9e9;color:blue;">int</span>&nbsp;<span style="background:#e9e9e9;color:gray;">end</span>)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">for</span>&nbsp;(<span style="background:#e9e9e9;color:blue;">int</span>&nbsp;<span style="background:#e9e9e9;color:#1f377f;">i</span>&nbsp;=&nbsp;<span style="background:#e9e9e9;color:gray;">begin</span>;&nbsp;<span style="background:#e9e9e9;color:#1f377f;">i</span>&nbsp;&lt;&nbsp;<span style="background:#e9e9e9;color:gray;">end</span>;&nbsp;++<span style="background:#e9e9e9;color:#1f377f;">i</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">co_yield</span>&nbsp;<span style="background:#e9e9e9;color:#1f377f;">i</span>;
}
<span style="background:#e9e9e9;color:#2b91af;">my_range</span>&lt;<span style="background:#e9e9e9;color:blue;">int</span>&gt;&nbsp;<span style="background:#e9e9e9;color:#74531f;">range14</span>(<span style="background:#e9e9e9;color:blue;">int</span>&nbsp;<span style="background:#e9e9e9;color:gray;">begin</span>,&nbsp;<span style="background:#e9e9e9;color:blue;">int</span>&nbsp;<span style="background:#e9e9e9;color:gray;">end</span>)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8a1bff;">CO_BEGIN</span>(<span style="background:#e9e9e9;color:#2b91af;">my_range</span>&lt;<span style="background:#e9e9e9;color:blue;">int</span>&gt;,&nbsp;<span style="background:#e9e9e9;color:gray;">begin</span>,&nbsp;<span style="background:#e9e9e9;color:gray;">end</span>,&nbsp;i&nbsp;=&nbsp;<span style="background:#e9e9e9;color:blue;">int</span>{});
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">for</span>&nbsp;(i&nbsp;=&nbsp;<span style="background:#e9e9e9;color:gray;">begin</span>;&nbsp;i&nbsp;&lt;&nbsp;<span style="background:#e9e9e9;color:gray;">end</span>;&nbsp;++i)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8a1bff;">CO_YIELD</span>(i);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8a1bff;">CO_END</span>();
}
 
<span style="background:#e9e9e9;color:blue;">void</span>&nbsp;<span style="background:#e9e9e9;color:#74531f;">example</span>()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">for</span>&nbsp;(<span style="background:#e9e9e9;color:blue;">int</span>&nbsp;<span style="background:#e9e9e9;color:#1f377f;">i</span>&nbsp;:&nbsp;<span style="background:#e9e9e9;color:#74531f;">range14</span>(2,&nbsp;10))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;<span style="background:#e9e9e9;color:teal;">&lt;&lt;</span>&nbsp;<span style="background:#e9e9e9;color:#1f377f;">i</span>&nbsp;<span style="background:#e9e9e9;color:teal;">&lt;&lt;</span>&nbsp;<span style="background:#e9e9e9;color:#e21f1f;">&#39;</span><span style="background:#e9e9e9;color:#a31515;">,</span><span style="background:#e9e9e9;color:#e21f1f;">&#39;</span>;
}</pre>


Importantly, the return type of the coroutine, in this case <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:#2b91af;">my_future</span><span style="color:#111111;">&lt;</span><span style="color:blue;">int</span><span style="color:#111111;">&gt;</span></span>, must implement a certain interface in order for the coroutine body to interact with it. In brief, this interface consists of the return type having an associated <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#2b91af;">promise_type</span> which implements certain functions. For <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:#8f08c4;">co_yield</span> &lt;expr&gt;;</span> statements, the <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;">&lt;expr&gt;;</span> value is forwarded to 
<span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:#2b91af;">promise_type</span>::<span style="color:#74531f;">yield_value</span>(&lt;expr&gt;)</span> 
which, in our example, somehow forwards it to the return value 
<span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:#2b91af;">my_range</span><span style="color:#111111;">&lt;</span><span style="color:blue;">int</span><span style="color:#111111;">&gt;</span></span> 
so that the caller can consume it. Similar "customization points" are required for determining how the other situations are handled.


### <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8f08c4;">co_return</span>
To return a value from a coroutine we must use <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8f08c4;">co_return</span> instead of normal <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8f08c4;">return</span>. This special return keyword helps the compiler know that the current function is a coroutine as opposed to a normal function. In particular, from the function signature 
<span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:#2b91af;">my_future</span><span style="color:#111111;">&lt;</span><span style="color:blue;">int</span><span style="color:#111111;">&gt;</span><span style="color:#74531f;"> g20<span style="color:#111110">()</span></span></span>
there is no way to tell if the body of the function is coroutine or a normal function that just happens to return a 
<span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:#2b91af;">my_future</span><span style="color:#111111;">&lt;</span><span style="color:blue;">int</span><span style="color:#111111;">&gt;</span></span>. 


More generally, whenever the compiler sees at least one   <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8f08c4;">co_await</span>, <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8f08c4;">co_yield</span> or <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8f08c4;">co_return</span> keyword, it will convert the function body into a coroutine by performing the "coroutine transformation." Importantly, this transformation is just an implementation detail. The caller does not know or care if 
<span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:#2b91af;">my_future</span><span style="color:#111111;">&lt;</span><span style="color:blue;">int</span><span style="color:#111111;">&gt;</span><span style="color:#74531f;">  g20<span style="color:#111110">()</span></span></span> 
is a coroutine or implements the required logic in some other way.


Next, we will discuss precisely that, how to implement the coroutine transformation manually and then introduce the macros you see above to aid readability.


## The Coroutine Transformation


At the core of the coroutine specification is a relatively mechanical transformation. Every coroutine function is effectively transformed into two functions. The first (_outer function_) performs the following:
- Constructs the so-called promise type 
<span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:#2b91af;">&lt;function-return-type&gt;</span>::<span style="color:#2b91af;">promise_type</span><span style="color:#74531f;"> promise</span></span>. 
The role of the promise type is to decide when to start and/or resume the coroutine and what to do when it yields a value or returns.
- Construct the return type <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#2b91af;">&lt;function-return-type&gt;</span> which in our first example is 
<span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:#2b91af;">my_future</span><span style="color:#111111;">&lt;</span><span style="color:blue;">int</span><span style="color:#111111;">&gt;</span></span>. 
This is obtained by calling <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f;">promise.get_return_object<span style="color:#111110">()</span></span>. This will be what is returned to the caller.
- Query the <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#2b91af;">promise_type</span> and decide if the coroutine body should be started now (before returning to the caller) or later (possibly by the caller). This is determined by the result of <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f;">promise.initial_suspend<span style="color:#111110">()</span></span>. If we should start now then we call the second function which contains the user code.
- Finally, we return the result of <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f;">promise.get_return_object<span style="color:#111110">()</span></span> to the caller.


The second function (_inner function_) of the transformation will contain the actual body of the coroutine that the user wrote. Each time   <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8f08c4;">co_await</span>, <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8f08c4;">co_yield</span> or <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8f08c4;">co_return</span> is seen, code is inserted to perform the required logic and allow the coroutine to be suspended/resumed at this location. These are called suspension points.


Below is some C++ inspired pseudocode that loosely implements the required logic which we explain next. The outer function <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f;">g_inlined</span> is intended  to have the same behavior  as <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f;">g20<span style="color:#111110">()</span></span>, <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f;">g14<span style="color:#111110">()</span></span> above.


<pre style="font-family:Consolas;font-size:13px;color:black;background:#e9e9e8;border-radius:10px;padding-left:10px;padding-right:5px;"><span style="background:#e9e9e9;color:#2b91af;">my_future</span>&lt;<span style="background:#e9e9e9;color:blue;">int</span>&gt;&nbsp;<span style="background:#e9e9e9;color:#74531f;">g_inline</span>()
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:green;">//&nbsp;Construct&nbsp;the&nbsp;coroutine&nbsp;frame&nbsp;and&nbsp;promise</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:blue;">struct</span>&nbsp;<span style="background:#e9e9e9;color:#2b91af;">coroutine_frame</span>&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#2b91af;">my_future</span>&lt;<span style="background:#e9e9e9;color:blue;">int</span>&gt;::<span style="background:#e9e9e9;color:#2b91af;">promise_type</span>&nbsp;promise;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::<span style="background:#e9e9e9;color:#2b91af;">function</span>&lt;<span style="background:#e9e9e9;color:blue;">void</span>(<span style="background:#e9e9e9;color:blue;">void</span>)&gt;&nbsp;inner_fn;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:blue;">void</span>*&nbsp;suspend_address&nbsp;=&nbsp;&amp;InitialSuspend;
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:blue;">auto</span>&nbsp;<span style="background:#e9e9e9;color:#1f377f;">frame</span>&nbsp;=&nbsp;<span style="background:#e9e9e9;color:blue;">new</span>&nbsp;<span style="background:#e9e9e9;color:#2b91af;">coroutine_frame</span>;
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:green;">//&nbsp;define&nbsp;the&nbsp;inner&nbsp;function</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#1f377f;">frame</span>-&gt;inner_fn&nbsp;<span style="background:#e9e9e9;color:teal;">=</span>&nbsp;[<span style="background:#e9e9e9;color:#1f377f;">frame</span>]()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:green;">//&nbsp;jump&nbsp;to&nbsp;wherever&nbsp;we&nbsp;left&nbsp;off.</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">goto</span>&nbsp;frame-&gt;suspend_address;
InitialSuspend:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:green;">//&nbsp;&lt;----&nbsp;beginning&nbsp;of&nbsp;user&nbsp;code.&nbsp;----&gt;</span>
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:green;">//&nbsp;int&nbsp;i&nbsp;=&nbsp;co_await&nbsp;h();</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:blue;">auto</span>&nbsp;<span style="background:#e9e9e9;color:#1f377f;">awaiter_h</span>&nbsp;=&nbsp;<span style="background:#e9e9e9;color:#74531f;">h</span>();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">if</span>&nbsp;(!<span style="background:#e9e9e9;color:#1f377f;">awaiter_h</span>.<span style="background:#e9e9e9;color:#74531f;">await_ready</span>())&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#1f377f;">frame</span>-&gt;suspend_address&nbsp;=&nbsp;&amp;Suspend_1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#1f377f;">awaiter_h</span>.<span style="background:#e9e9e9;color:#74531f;">await_suspend</span>(<span style="background:#e9e9e9;color:#1f377f;">frame</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">return</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
Suspend_1:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:blue;">int</span>&nbsp;<span style="background:#e9e9e9;color:#1f377f;">i</span>&nbsp;=&nbsp;<span style="background:#e9e9e9;color:#1f377f;">awaiter_h</span>.<span style="background:#e9e9e9;color:#74531f;">await_resume</span>();
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:green;">//&nbsp;normal&nbsp;code</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">if</span>&nbsp;(<span style="background:#e9e9e9;color:#1f377f;">i</span>&nbsp;==&nbsp;42)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#1f377f;">i</span>&nbsp;=&nbsp;0;
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:green;">//&nbsp;co_return&nbsp;i;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#1f377f;">frame</span>-&gt;suspend_address&nbsp;=&nbsp;&amp;FinalSuspend;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#1f377f;">frame</span>-&gt;promise.<span style="background:#e9e9e9;color:#74531f;">return_value</span>(<span style="background:#e9e9e9;color:#1f377f;">i</span>);
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:green;">//&nbsp;&lt;----&nbsp;end&nbsp;of&nbsp;user&nbsp;code.&nbsp;----&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:green;">//&nbsp;final&nbsp;suspend</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">if</span>&nbsp;(!promise.final_suspend().await_ready())&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#1f377f;">frame</span>-&gt;suspend_address&nbsp;=&nbsp;&amp;FinalSuspend;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">return</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
FinalSuspend:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:blue;">delete</span>&nbsp;<span style="background:#e9e9e9;color:#1f377f;">frame</span>;
&nbsp;&nbsp;&nbsp;&nbsp;};
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#2b91af;">my_future</span>&lt;<span style="background:#e9e9e9;color:blue;">int</span>&gt;&nbsp;<span style="background:#e9e9e9;color:#1f377f;">ret</span>&nbsp;=&nbsp;<span style="background:#e9e9e9;color:#1f377f;">frame</span>-&gt;promise.<span style="background:#e9e9e9;color:#74531f;">get_return_object</span>();
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:green;">//&nbsp;call&nbsp;the&nbsp;inner&nbsp;function&nbsp;if&nbsp;we&nbsp;are&nbsp;ready.</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">if</span>&nbsp;(<span style="background:#e9e9e9;color:#1f377f;">frame</span>-&gt;promise.<span style="background:#e9e9e9;color:#74531f;">initial_suspend</span>().<span style="background:#e9e9e9;color:#74531f;">await_ready</span>())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#1f377f;">frame</span>-&gt;inner_fn<span style="background:#e9e9e9;color:teal;">()</span>;
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">return</span>&nbsp;<span style="background:#e9e9e9;color:#1f377f;">ret</span>;
}</pre>


First, the so-called <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#2b91af;">coroutine_frame</span> is allocated. The frame will contain the <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#2b91af;">promise_type</span> and space for the local variables used in the inner function, which for clarity is being managed using 
<span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:#111112;">std</span><span style="color:#111111;">::</span><span style="color:#2b91af;">function</span><span style="color:#111111;">&lt;</span><span style="color:blue;">void</span><span style="color:#111111;">(</span><span style="color:blue;">void</span><span style="color:#111111;">)&gt;</span></span>. 


This inner function can be called many times with the desired logic being that the function should resume from wherever it left off. The code above achieves this using a hypothetical syntax for storing the addresses of <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8f08c4;">goto</span> labels. In particular, each time we enter the inner function we will perform 
<span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:#8f08c4;">goto</span> <span style="color:#74531f;">suspend_address</span></span>
 where <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f;">suspend_address</span> is the location in the function that is just after where we suspended last. 




The first time we enter the function <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f;">suspend_address</span> will have the initial  value of <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f;">InitialSuspend:</span> and begin executing the user code. At some point the execution will hit a <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8f08c4;">co_*</span> statement, in this case 
<span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:blue;">int </span><span style="color:#74531f;">i = </span><span style="color:#8f08c4;">co_await</span><span style="color:#74531f;"> h<span style="color:#111110">()</span></span></span>. 
This statement will be transformed as shown above to first query if the value return by 
<span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:blue;">auto </span><span style="color:#74531f;">awaiter_h = h<span style="color:#111110">()</span></span></span>
 is ready to be consumed. This is achieved by calling <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f;">awaiter_h.await_ready<span style="color:#111110">()</span></span>. 


If <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f;">awaiter_h.await_ready<span style="color:#111110">()</span></span> returns <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:blue;">true</span> then we need to suspend the coroutine. This is achieved by updating the <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f;">suspend_address</span> to be just after the current   <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8f08c4;">co_await</span> statement and calling <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f;">awaiter_h.await_suspend<span style="color:#111110">(</span>frame<span style="color:#111110">)</span></span> which gives <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f;">awaiter_h</span> the responsibility to resume this coroutine whenever the value does become available. Finally, we return from the inner function, in this case back to the outer function and then to initial caller. Through some other mechanism, <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f;">awaiter_h</span> will eventually  have a value (or exception) and the inner function will be resumed. This time the <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"> <span style="color:#8f08c4;">goto </span><span style="color:#74531f;">suspend_address</span></span> statement will jump us back to just after the <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8f08c4;">return</span> that was taken last time, i.e. <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f;">Suspend_1</span>.


Alternatively, <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f;">awaiter_h.await_ready<span style="color:#111110">()</span></span> could have returned <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:blue;">true</span> and the program would similarly be at the <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f;">Suspend_1</span> location. Regardless, the result of 
<span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:#8f08c4;">co_await</span><span style="color:#74531f;"> h<span style="color:#111110">()</span></span></span>
 statement is ready and can be obtained by calling <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f;">awaiter_h.await_resume<span style="color:#111110">()</span></span>.


The 
<span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:#8f08c4;">co_return</span> <span style="color:#74531f;">i</span></span>
 statement is handled by calling <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f;">promise.return_value<span style="color:#111110">(</span>i<span style="color:#111110">)</span>;</span> and then immidiately proceeding to the so-called <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f;">final_suspend</span>. The role of <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f;">final_suspend</span> is to determine if the current <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#2b91af;">coroutine_frame</span> which contains the user's <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#2b91af;">promise_type</span> is safe to be deleted. Often it is preferred to not delete the frame at this time and instead allow the caller/consumer to delete the frame once they have obtained the result, i.e. <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f;">i</span> in this case.


## Issues and Solutions


The code given above should give you an intuition  about what the compiler is doing. However, there are several issues in emulating as described above.


### <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:#8f08c4;">goto</span><span style="color:#74531f;"> suspent_point</span></span>


First, is that standard C++ does not allow you to take the address of a <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8f08c4;">goto</span> label. To address this the <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8f08c4;">goto</span> statements can be replaced with a <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8f08c4;">switch</span> statement. The function body would then look like

<!-- ```C++
{
  switch(frame->suspend_point)
  {
  case SuspendPoint::InitialSuspend:
    // int i = co_await h();
    auto awaiter_h = h();
    if (!awaiter_h.await_ready()) {
        frame->suspend_point = (SuspendPoint)1;
        awaiter_h.await_suspend(frame);
        return;
    }
  case (SuspendPoint)1:
    int i = awaiter_h.await_resume();
  
    ...

  case SuspendPoint::FinalSuspend:
    delete frame;
  }
}
``` -->

<pre style="font-family:Consolas;font-size:13px;color:black;background:#e9e9e8;border-radius:10px;padding-left:10px;padding-right:5px;">{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">switch</span>&nbsp;(<span style="background:#e9e9e9;color:#1f377f;">frame</span>-&gt;suspend_point)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">case</span>&nbsp;<span style="background:#e9e9e9;color:#2b91af;">SuspensionPoint</span>::<span style="background:#e9e9e9;color:darkslategray;">InitialSuspend</span>:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:green;">//&nbsp;int&nbsp;i&nbsp;=&nbsp;co_await&nbsp;h();</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:blue;">auto</span>&nbsp;<span style="background:#e9e9e9;color:#1f377f;">awaiter_h</span>&nbsp;=&nbsp;<span style="background:#e9e9e9;color:#74531f;">h</span>();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">if</span>&nbsp;(!<span style="background:#e9e9e9;color:#1f377f;">awaiter_h</span>.<span style="background:#e9e9e9;color:#74531f;">await_ready</span>())&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#1f377f;">frame</span>-&gt;suspend_point&nbsp;=&nbsp;(SuspendPoint)1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#1f377f;">awaiter_h</span>.<span style="background:#e9e9e9;color:#74531f;">await_suspend</span>(<span style="background:#e9e9e9;color:#1f377f;">frame</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">return</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">case</span>&nbsp;(<span style="background:#e9e9e9;color:#2b91af;">SuspensionPoint</span>)1:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:blue;">int</span>&nbsp;<span style="background:#e9e9e9;color:#1f377f;">i</span>&nbsp;=&nbsp;<span style="background:#e9e9e9;color:#1f377f;">awaiter_h</span>.<span style="background:#e9e9e9;color:#74531f;">await_resume</span>();
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:green;">//...</span>
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">case</span>&nbsp;<span style="background:#e9e9e9;color:#2b91af;">SuspensionPoint</span>::<span style="background:#e9e9e9;color:darkslategray;">FinalSuspend</span>:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:blue;">delete</span>&nbsp;<span style="background:#e9e9e9;color:#1f377f;">frame</span>;
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>


Using a switch statement is almost functionally equivalent. The main downside is that users can not use switch statements across <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8f08c4;">co_\*</span> keywords (looking forward <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8a1bff;">CO_\*</span> macros). Interestingly, switch statements allow for <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8f08c4;">case</span> locations that are in a nested scope, e.g. using can suspend in the middle of a for-loop and the switch statement can jump back to it upon resume.
 

### Local variables


The second issue regards saving the state of local variables between suspend and resume calls. For example, if before 
<span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:#8f08c4;">co_await</span><span style="color:#74531f;"> h<span style="color:#111110">()</span></span></span>  the user has constructed some local variable and we suspended for <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f;"> h<span style="color:#111110">()</span></span>, then when the function is resumed that local variable would be uninitialized.


The compiler handles this in the transformation by moving any declaration of local variables into the <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#2b91af;">coroutine_frame</span> as opposed to being the body of our inner function. They are then destroyed when the coroutine completes.


While one can manually perform the transformation, we will instead consider an alternative solution. In particular, we will place/require all local variables to be declared in the lambda capture. While this results in slightly different semantics, it will enable us to write the <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8a1bff;">CO_BEGIN</span> macro. 


A similar issue regards the lifetime of the awaiter when the coroutine is suspended, i.e. <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f;">awaiter_h</span> in the example above. This can be resolved by storing the awaiter either in a fixed sized buffer in <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#2b91af;">coroutine_frame</span> or allocating it on the heap if it is too large to fit in the buffer. 


### <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="background:#e9e9e9;color:#111112;">std</span><span style="color:#111111;">::</span><span style="color:#2b91af;">coroutine_handle</span><span style="color:#111111;">&lt;</span><span style="color:#2b91af;">promise_type</span><span style="color:#111111;">&gt;</span></span>

The final issue regards compatibility with C++20 coroutines. Ideally we can choose to implement our coroutines manually using the pattern outlined here or use the C++20 keywords. However, the primary barrier in achieving this is that C++20 defines <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f;">&lt;awaiter&gt;.await_suspend</span> as taking a 
<span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:#111112;">std</span><span style="color:#111111;">::</span><span style="color:#2b91af;">coroutine_handle</span><span style="color:#111111;">&lt;</span><span style="color:#2b91af;">promise_type</span><span style="color:#111111;">&gt;</span></span>
as input while our example takes 
<span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:#2b91af;">&lt;function-name&gt;</span><span style="color:#111111;">::</span><span style="color:#2b91af;">coroutine_frame</span><span style="color:#74531f;">\*</span></span>. 


Intuitively, these two parameters represent the same thing. Both are a pointer to the coroutine frame and provide a way for the awaiter to resume this coroutine once the thing being awaited becomes ready. However, the way we resume the 
<span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:#2b91af;">&lt;function-name&gt;</span><span style="color:#111111;">::</span><span style="color:#2b91af;">coroutine_frame</span><span style="color:#74531f;">\*</span></span>
vs a C++20 coroutine are concretely different. Moreover, there is no way to convert our 
<span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:#2b91af;">&lt;function-name&gt;</span><span style="color:#111111;">::</span><span style="color:#2b91af;">coroutine_frame</span><span style="color:#74531f;">\*</span></span>
into a 
<span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:#111112;">std</span><span style="color:#111111;">::</span><span style="color:#2b91af;">coroutine_handle</span><span style="color:#111111;">&lt;</span><span style="color:#2b91af;">promise_type</span><span style="color:#111111;">&gt;</span></span>
since we can not modify that type. 


This issue could be resolved by giving <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#2b91af;">promise_type</span> another customization point which 
<span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:#111112;">std</span><span style="color:#111111;">::</span><span style="color:#2b91af;">coroutine_handle</span><span style="color:#111111;">&lt;</span><span style="color:#2b91af;">promise_type</span><span style="color:#111111;">&gt;</span></span> 
interacts with and then dispatches to the correct method for resuming to coroutine. However, this is not part of the standard.


Instead, we will define our own 
<span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:#111112;">macoro</span><span style="color:#111111;">::</span><span style="color:#2b91af;">coroutine_handle</span><span style="color:#111111;">&lt;</span><span style="color:#2b91af;">promise_type</span>&gt;</span></span>
which can hold either a 
<span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:#111112;">std</span><span style="color:#111111;">::</span><span style="color:#2b91af;">coroutine_handle</span><span style="color:#111111;">&lt;</span><span style="color:#2b91af;">promise_type</span><span style="color:#111111;">&gt;</span></span>
 or a 
<span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:#2b91af;">&lt;function-name&gt;</span><span style="color:#111111;">::</span><span style="color:#2b91af;">coroutine_frame</span><span style="color:#74531f;">\*</span></span>.
As such, our coroutines will only work with a <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#2b91af;">promise_type</span> that can take a 
<span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:#111112;">macoro</span><span style="color:#111111;">::</span><span style="color:#2b91af;">coroutine_handle</span><span style="color:#111111;">&lt;</span><span style="color:#2b91af;">*</span><span style="color:#111111;">&gt;</span></span> as input to <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f;">&lt;awaiter&gt;.await_suspend<span style="color:#111110">(...)</span></span>.


This is somewhat unfortunate  because thirdparty awaitable types which are intended for C++20 will most likely not work out of the box. However, this is probably unavoidable given that they will likely take other dependencies  to C++20.


### Allocations


The current strategy requires several allocations. First, we must allocate the <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#2b91af;">coroutine_frame</span>. C++20 defines a way to allow the user to control where this allocation happens. A description of it can be found in Lewis Baker's excellent [blog posts](https://lewissbaker.github.io/). A similar strategy can be applied to our framework with some modifications. 


Another allocation likely occurs for the 
<span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:#111112;">std</span><span style="color:#111111;">::</span><span style="color:#2b91af;">function</span><span style="color:#111111;">&lt;</span><span style="color:blue;">void</span><span style="color:#111111;">(</span><span style="color:blue;">void</span><span style="color:#111111;">)&gt;</span></span>. However, this is not required. We can instead define the function

<!-- ```C++
template<typename lambda_type, typename promise_type>
coroutine_frame<lambda_type, promise_type>* makeFrame(lambda_type&& body);
``` -->

<pre style="font-family:Consolas;font-size:13px;color:black;background:#e9e9e8;border-radius:10px;padding-left:10px;padding-right:5px;"><span style="background:#e9e9e9;color:blue;">template</span>&lt;<span style="background:#e9e9e9;color:blue;">typename</span>&nbsp;<span style="background:#e9e9e9;color:#2b91af;">lambda_type</span>,&nbsp;<span style="background:#e9e9e9;color:blue;">typename</span>&nbsp;<span style="background:#e9e9e9;color:#2b91af;">promise_type</span>&gt;
<span style="background:#e9e9e9;color:#2b91af;">coroutine_frame</span>&lt;<span style="background:#e9e9e9;color:#2b91af;">lambda_type</span>,&nbsp;<span style="background:#e9e9e9;color:#2b91af;">promise_type</span>&gt;*&nbsp;<span style="background:#e9e9e9;color:#74531f;">makeFrame</span>(<span style="background:#e9e9e9;color:#2b91af;">lambda_type</span>&amp;&amp;&nbsp;<span style="background:#e9e9e9;color:gray;">inner_fn</span>);</pre>

that returns a frame that stores the inner function with type <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#2b91af;">lambda_type</span> inside the <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#2b91af;">coroutine_frame</span>. Then the inner function will take a pointer to the frame as its only parameter.


The final allocation is with respect to the storage of any awaiters that are produced during an active   <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8f08c4;">co_await</span>. As suggested previously, these can be partially handled by having an additional buffer within the <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#2b91af;">coroutine_frame</span>. However, it is still possible that the coroutine body awaits an awaiter that does not fit in the buffer and then an allocation would occur. However, it is possible for this to result in a compile time error. This can then be combined with allowing the buffer size to be a template parameter, i.e. an input to <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8a1bff;">CO_BEGIN</span>. 


Combining these we could obtain a coroutine that is guaranteed to not to allocation any memory, something that C++20 coroutines can not currently achieve 100 percent of the time.

## Macros for Readability

Using the pattern above we can define the macros shown in the beginning. A prototype of these ideas can be found in the [macoro](http://github.com/ladnir/macoro) repo. Below is a simplified definition of the main macros. In summary, <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8a1bff;">CO_BEGIN</span> begins the call to <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f;">makeFrame</span> that allocates the frame with the inner function being stored inline. The closing brace of the lambda and <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f;">makeFrame</span> function is in <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8a1bff;">CO_END</span>. The first time we enter the inner function we finish the initial suspend (which was started in the outer function in <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8a1bff;">CO_END</span>) by calling <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f;">await_resume</span> and destroying  the awaiter. 



<span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8a1bff;">CO_AWAIT</span> first computes the type of the awaiter and then constructs  it within the frame (or on the heap). It then performs the <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f;">await_ready/await_suspend/await_resume</span> procedure. If it does suspend, it updates the suspend point with the line number.


<span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8a1bff;">CO_END</span> performs the catch block, passing any exception to the <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#74531f;">promise</span> and then performs the final suspend. This completes the definition of the inner function. <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;color:#8a1bff;">CO_END</span> then completes the outer function by constructing the return object and starting the initial suspend. If ready we start the coroutine by calling the inner function and then return the return type. 

### <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:#8a1bff;">CO_BEGIN</span><span style="color:#74531f;">(return_type, ...)</span></span>

<!-- ```C++
using promise_type = return_type::promise_type;
using Handle = coroutine_handle<promise_type>;
// make frame with inline body.
auto frame = makeFrame<promise_type>(
    [](FrameBase<promise_type>* frame) mutable {

        promise_type& promise = frame->promise;
        try {
            // jump to where we suspended
            switch (frame->getSuspendPoint())
            {
            case SuspensionPoint::InitialSuspend:
            { // ------- initial suspend continued -------
                using Awaiter = typename awaiter_for<promise_type,
                    decltype(promise.initial_suspend())>;
                frame->getAwaiter<Awaiter>().await_resume();
                frame->destroyAwaiter<Awaiter>();
            } // -------- end of initial suspend ---------
            // ---------- beginning of user code -----------
``` -->
<pre style="font-family:Consolas;font-size:13px;color:black;background:#e9e9e8;border-radius:10px;padding-left:10px;padding-right:5px;"><span style="background:#e9e9e9;color:blue;">using</span>&nbsp;<span style="background:#e9e9e9;color:#2b91af;">promise_type</span>&nbsp;=&nbsp;<span style="background:#e9e9e9;color:#2b91af;">return_type</span>::<span style="background:#e9e9e9;color:#2b91af;">promise_type</span>;
<span style="background:#e9e9e9;color:blue;">using</span>&nbsp;<span style="background:#e9e9e9;color:#2b91af;">Handle</span>&nbsp;=&nbsp;<span style="background:#e9e9e9;color:#2b91af;">coroutine_handle</span>&lt;<span style="background:#e9e9e9;color:#2b91af;">promise_type</span>&gt;;
<span style="background:#e9e9e9;color:green;">//&nbsp;make&nbsp;frame&nbsp;with&nbsp;inline&nbsp;body.</span>
<span style="background:#e9e9e9;color:blue;">auto</span>&nbsp;<span style="background:#e9e9e9;color:#1f377f;">frame</span>&nbsp;=&nbsp;<span style="background:#e9e9e9;color:#74531f;">makeFrame</span>&lt;<span style="background:#e9e9e9;color:#2b91af;">promise_type</span>&gt;(
&nbsp;&nbsp;&nbsp;&nbsp;[<span style="background:#e9e9e9;color:#8a1bff;">__VA_ARGS__</span>](<span style="background:#e9e9e9;color:#2b91af;">FrameBase</span>&lt;<span style="background:#e9e9e9;color:#2b91af;">promise_type</span>&gt;*&nbsp;<span style="background:#e9e9e9;color:gray;">frame</span>)&nbsp;<span style="background:#e9e9e9;color:blue;">mutable</span>&nbsp;{
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#2b91af;">promise_type</span>&amp;&nbsp;<span style="background:#e9e9e9;color:#1f377f;">promise</span>&nbsp;=&nbsp;<span style="background:#e9e9e9;color:gray;">frame</span>-&gt;promise;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">try</span>&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:green;">//&nbsp;jump&nbsp;to&nbsp;where&nbsp;we&nbsp;suspended</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">switch</span>&nbsp;(<span style="background:#e9e9e9;color:gray;">frame</span>-&gt;<span style="background:#e9e9e9;color:#74531f;">getSuspendPoint</span>())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">case</span>&nbsp;<span style="background:#e9e9e9;color:#2b91af;">SuspensionPoint</span>::<span style="background:#e9e9e9;color:darkslategray;">InitialSuspend</span>:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<span style="background:#e9e9e9;color:green;">//&nbsp;-------&nbsp;initial&nbsp;suspend&nbsp;continued&nbsp;-------</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:blue;">using</span>&nbsp;<span style="background:#e9e9e9;color:#2b91af;">Awaiter</span>&nbsp;=&nbsp;<span style="background:#e9e9e9;color:blue;">typename</span>&nbsp;<span style="background:#e9e9e9;color:#2b91af;">awaiter_for</span>&lt;<span style="background:#e9e9e9;color:#2b91af;">promise_type</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:blue;">decltype</span>(<span style="background:#e9e9e9;color:#1f377f;">promise</span>.<span style="background:#e9e9e9;color:#74531f;">initial_suspend</span>())&gt;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:gray;">frame</span>-&gt;<span style="background:#e9e9e9;color:#74531f;">getAwaiter</span>&lt;<span style="background:#e9e9e9;color:#2b91af;">Awaiter</span>&gt;().<span style="background:#e9e9e9;color:#74531f;">await_resume</span>();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:gray;">frame</span>-&gt;<span style="background:#e9e9e9;color:#74531f;">destroyAwaiter</span>&lt;<span style="background:#e9e9e9;color:#2b91af;">Awaiter</span>&gt;();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span style="background:#e9e9e9;color:green;">//&nbsp;--------&nbsp;end&nbsp;of&nbsp;initial&nbsp;suspend&nbsp;---------</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:green;">//&nbsp;----------&nbsp;beginning&nbsp;of&nbsp;user&nbsp;code&nbsp;-----------</span></pre>


###  <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:#8a1bff;">CO_AWAIT</span><span style="color:#74531f;">(RETURN_VAL, EXPR)</span></span>

<!-- ```C++
            {
                using Awaiter = awaiter_for<promise_type, decltype(EXPR)>;
                {
                    auto& awaiter = frame->constructAwaiter(EXPR);
                    if (!awaiter.await_ready()) {
                        // suspend-coroutine
                        frame->setSuspendPoint((SuspensionPoint)__LINE__);

                        // call awaiter.await_suspend(). If it's void return, then return true.
                        if (await_suspend(awaiter, Handle::from_promise(promise)))
                            return;
                    }
                }
                // resume-point, __LINE__ will be the same in macro.
            case SuspensionPoint(__LINE__):
                RETURN_VAL = frame->getAwaiter<Awaiter>().await_resume();
                frame->destroyAwaiter<Awaiter>();
            }
``` -->
<pre style="font-family:Consolas;font-size:13px;color:black;background:#e9e9e8;border-radius:10px;padding-left:10px;padding-right:5px;">{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:blue;">using</span>&nbsp;<span style="background:#e9e9e9;color:#2b91af;">Awaiter</span>&nbsp;=&nbsp;<span style="background:#e9e9e9;color:#2b91af;">awaiter_for</span>&lt;<span style="background:#e9e9e9;color:#2b91af;">promise_type</span>,&nbsp;<span style="background:#e9e9e9;color:blue;">decltype</span>(<span style="background:#e9e9e9;color:#8a1bff;">EXPR</span>)&gt;;
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:blue;">auto</span>&amp;&nbsp;<span style="background:#e9e9e9;color:#1f377f;">awaiter</span>&nbsp;=&nbsp;<span style="background:#e9e9e9;color:gray;">frame</span>-&gt;<span style="background:#e9e9e9;color:#74531f;">constructAwaiter</span>(<span style="background:#e9e9e9;color:#8a1bff;">EXPR</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">if</span>&nbsp;(!<span style="background:#e9e9e9;color:#1f377f;">awaiter</span>.await_ready())&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:green;">//&nbsp;suspend-coroutine</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:gray;">frame</span>-&gt;<span style="background:#e9e9e9;color:#74531f;">setSuspendPoint</span>((<span style="background:#e9e9e9;color:#2b91af;">SuspensionPoint</span>)<span style="background:#e9e9e9;color:#8a1bff;">__LINE__</span>);
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:green;">//&nbsp;call&nbsp;awaiter.await_suspend().&nbsp;If&nbsp;it&#39;s&nbsp;void&nbsp;return,&nbsp;then&nbsp;return&nbsp;true.</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">if</span>&nbsp;(await_suspend(<span style="background:#e9e9e9;color:#1f377f;">awaiter</span>,&nbsp;<span style="background:#e9e9e9;color:#2b91af;">Handle</span>::<span style="background:#e9e9e9;color:#74531f;">from_promise</span>(<span style="background:#e9e9e9;color:#1f377f;">promise</span>)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">return</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:green;">//&nbsp;resume-point,&nbsp;__LINE__&nbsp;will&nbsp;be&nbsp;the&nbsp;same&nbsp;in&nbsp;macro.</span>
<span style="background:#e9e9e9;color:#8f08c4;">case</span>&nbsp;<span style="background:#e9e9e9;color:#2b91af;">SuspensionPoint</span>(<span style="background:#e9e9e9;color:#8a1bff;">__LINE__</span>):
&nbsp;&nbsp;&nbsp;&nbsp;RETURN_VAL&nbsp;=&nbsp;<span style="background:#e9e9e9;color:gray;">frame</span>-&gt;<span style="background:#e9e9e9;color:#74531f;">getAwaiter</span>&lt;<span style="background:#e9e9e9;color:#2b91af;">Awaiter</span>&gt;().await_resume();
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:gray;">frame</span>-&gt;<span style="background:#e9e9e9;color:#74531f;">destroyAwaiter</span>&lt;<span style="background:#e9e9e9;color:#2b91af;">Awaiter</span>&gt;();
}</pre>


###  <span style="border-radius:5px;padding-left:5px;padding-right:5px;padding-bottom:1px;background:#e9e9e9;font-family:Consolas;"><span style="color:#8a1bff;">CO_END</span><span style="color:#74531f;">()</span><span>

<!-- ```C++
            // ---------- end of user code -----------
            default:
            }
        }
        catch (...) {
            frame->promise.unhandled_exception();
        }

        // ---------- beginning of final suspend -----------
        using Awaiter = typename awaiter_for<promise_type, decltype(promise.final_suspend())>;
        auto& awaiter = frame->constructAwaiter(promise.final_suspend());
        auto handle = Handle::from_promise(promise);
        if (!awaiter.await_ready()) {
            // suspend-coroutine
            frame->setSuspendPoint(SuspensionPoint::FinalSuspend);
            // call awaiter.await_suspend(). If it's void return, then return true.
            if (await_suspend(awaiter, handle))
                return;
        }
        frame->getAwaiter<Awaiter>().await_resume();
        frame->destroyAwaiter<Awaiter>();
        handle.destroy();
        // ---------- end of final suspend -----------
    });

promise_type& promise = frame->promise;
auto ret = promise.get_return_object();

// ------- beginning of initial suspend ----------
using Awaiter = awaiter_for<promise_type, decltype(promise.initial_suspend())>;
auto& awaiter = frame->constructAwaiter(promise.initial_suspend());
auto handle = Handle::from_promise(promise);
if (!awaiter.await_ready())
{
    // suspend-coroutine
    frame->setSuspendPoint(SuspensionPoint::InitialSuspend);
    //call awaiter.await_suspend(). If it's void return, then return true
    if (await_suspend(awaiter, handle))
        return ret;
}

/*begin coroutine*/
(*frame)(frame);
return ret;
``` -->
<pre style="font-family:Consolas;font-size:13px;color:black;background:#e9e9e8;border-radius:10px;padding-left:10px;padding-right:5px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:green;">//&nbsp;----------&nbsp;end&nbsp;of&nbsp;user&nbsp;code&nbsp;-----------</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">default</span>:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">catch</span>&nbsp;(...)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:gray;">frame</span>-&gt;promise.<span style="background:#e9e9e9;color:#74531f;">unhandled_exception</span>();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:green;">//&nbsp;----------&nbsp;beginning&nbsp;of&nbsp;final&nbsp;suspend&nbsp;-----------</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:blue;">using</span>&nbsp;<span style="background:#e9e9e9;color:#2b91af;">Awaiter</span>&nbsp;=&nbsp;<span style="background:#e9e9e9;color:blue;">typename</span>&nbsp;<span style="background:#e9e9e9;color:#2b91af;">awaiter_for</span>&lt;<span style="background:#e9e9e9;color:#2b91af;">promise_type</span>,&nbsp;<span style="background:#e9e9e9;color:blue;">decltype</span>(<span style="background:#e9e9e9;color:#1f377f;">promise</span>.<span style="background:#e9e9e9;color:#74531f;">final_suspend</span>())&gt;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:blue;">auto</span>&amp;&nbsp;<span style="background:#e9e9e9;color:#1f377f;">awaiter</span>&nbsp;=&nbsp;<span style="background:#e9e9e9;color:gray;">frame</span>-&gt;<span style="background:#e9e9e9;color:#74531f;">constructAwaiter</span>(<span style="background:#e9e9e9;color:#1f377f;">promise</span>.<span style="background:#e9e9e9;color:#74531f;">final_suspend</span>());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:blue;">auto</span>&nbsp;<span style="background:#e9e9e9;color:#1f377f;">handle</span>&nbsp;=&nbsp;<span style="background:#e9e9e9;color:#2b91af;">Handle</span>::<span style="background:#e9e9e9;color:#74531f;">from_promise</span>(<span style="background:#e9e9e9;color:#1f377f;">promise</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">if</span>&nbsp;(!<span style="background:#e9e9e9;color:#1f377f;">awaiter</span>.<span style="background:#e9e9e9;color:#74531f;">await_ready</span>())&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:green;">//&nbsp;suspend-coroutine</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:gray;">frame</span>-&gt;<span style="background:#e9e9e9;color:#74531f;">setSuspendPoint</span>(<span style="background:#e9e9e9;color:#2b91af;">SuspensionPoint</span>::<span style="background:#e9e9e9;color:darkslategray;">FinalSuspend</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:green;">//&nbsp;call&nbsp;awaiter.await_suspend().&nbsp;If&nbsp;it&#39;s&nbsp;void&nbsp;return,&nbsp;then&nbsp;return&nbsp;true.</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">if</span>&nbsp;(<span style="background:#e9e9e9;color:#74531f;">await_suspend</span>(<span style="background:#e9e9e9;color:#1f377f;">awaiter</span>,&nbsp;<span style="background:#e9e9e9;color:#1f377f;">handle</span>))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">return</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:gray;">frame</span>-&gt;<span style="background:#e9e9e9;color:#74531f;">getAwaiter</span>&lt;<span style="background:#e9e9e9;color:#2b91af;">Awaiter</span>&gt;().<span style="background:#e9e9e9;color:#74531f;">await_resume</span>();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:gray;">frame</span>-&gt;<span style="background:#e9e9e9;color:#74531f;">destroyAwaiter</span>&lt;<span style="background:#e9e9e9;color:#2b91af;">Awaiter</span>&gt;();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#1f377f;">handle</span>.<span style="background:#e9e9e9;color:#74531f;">destroy</span>();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:green;">//&nbsp;----------&nbsp;end&nbsp;of&nbsp;final&nbsp;suspend&nbsp;-----------</span>
&nbsp;&nbsp;&nbsp;&nbsp;});
 
<span style="background:#e9e9e9;color:#2b91af;">promise_type</span>&amp;&nbsp;<span style="background:#e9e9e9;color:#1f377f;">promise</span>&nbsp;=&nbsp;<span style="background:#e9e9e9;color:#1f377f;">frame</span>-&gt;promise;
<span style="background:#e9e9e9;color:blue;">auto</span>&nbsp;<span style="background:#e9e9e9;color:#1f377f;">ret</span>&nbsp;=&nbsp;<span style="background:#e9e9e9;color:#1f377f;">promise</span>.<span style="background:#e9e9e9;color:#74531f;">get_return_object</span>();
 
<span style="background:#e9e9e9;color:green;">//&nbsp;-------&nbsp;beginning&nbsp;of&nbsp;initial&nbsp;suspend&nbsp;----------</span>
<span style="background:#e9e9e9;color:blue;">using</span>&nbsp;<span style="background:#e9e9e9;color:#2b91af;">Awaiter</span>&nbsp;=&nbsp;<span style="background:#e9e9e9;color:#2b91af;">awaiter_for</span>&lt;<span style="background:#e9e9e9;color:#2b91af;">promise_type</span>,&nbsp;<span style="background:#e9e9e9;color:blue;">decltype</span>(<span style="background:#e9e9e9;color:#1f377f;">promise</span>.<span style="background:#e9e9e9;color:#74531f;">initial_suspend</span>())&gt;;
<span style="background:#e9e9e9;color:blue;">auto</span>&amp;&nbsp;<span style="background:#e9e9e9;color:#1f377f;">awaiter</span>&nbsp;=&nbsp;<span style="background:#e9e9e9;color:#1f377f;">frame</span>-&gt;<span style="background:#e9e9e9;color:#74531f;">constructAwaiter</span>(<span style="background:#e9e9e9;color:#1f377f;">promise</span>.<span style="background:#e9e9e9;color:#74531f;">initial_suspend</span>());
<span style="background:#e9e9e9;color:blue;">auto</span>&nbsp;<span style="background:#e9e9e9;color:#1f377f;">handle</span>&nbsp;=&nbsp;<span style="background:#e9e9e9;color:#2b91af;">Handle</span>::<span style="background:#e9e9e9;color:#74531f;">from_promise</span>(<span style="background:#e9e9e9;color:#1f377f;">promise</span>);
<span style="background:#e9e9e9;color:#8f08c4;">if</span>&nbsp;(!<span style="background:#e9e9e9;color:#1f377f;">awaiter</span>.<span style="background:#e9e9e9;color:#74531f;">await_ready</span>())
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:green;">//&nbsp;suspend-coroutine</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#1f377f;">frame</span>-&gt;<span style="background:#e9e9e9;color:#74531f;">setSuspendPoint</span>(<span style="background:#e9e9e9;color:#2b91af;">SuspensionPoint</span>::<span style="background:#e9e9e9;color:darkslategray;">InitialSuspend</span>);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:green;">//call&nbsp;awaiter.await_suspend().&nbsp;If&nbsp;it&#39;s&nbsp;void&nbsp;return,&nbsp;then&nbsp;return&nbsp;true</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">if</span>&nbsp;(<span style="background:#e9e9e9;color:#74531f;">await_suspend</span>(<span style="background:#e9e9e9;color:#1f377f;">awaiter</span>,&nbsp;<span style="background:#e9e9e9;color:#1f377f;">handle</span>))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="background:#e9e9e9;color:#8f08c4;">return</span>&nbsp;<span style="background:#e9e9e9;color:#1f377f;">ret</span>;
}
 
<span style="background:#e9e9e9;color:green;">/*begin&nbsp;coroutine*/</span>
(*<span style="background:#e9e9e9;color:#1f377f;">frame</span>)(<span style="background:#e9e9e9;color:#1f377f;">frame</span>);
<span style="background:#e9e9e9;color:#8f08c4;">return</span>&nbsp;<span style="background:#e9e9e9;color:#1f377f;">ret</span>;</pre>